"""
Database Manager
Handles database connections, operations, and HIPAA compliance features
"""

import os
import logging
import json
from typing import Optional, List, Dict, Any, Tuple
from contextlib import contextmanager
from datetime import datetime
import hashlib
import secrets
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64

from sqlalchemy import create_engine, event, MetaData
from sqlalchemy.engine import Engine
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.pool import QueuePool

from config.config import DATABASE_CONFIG, SECURITY_CONFIG
from .database_models import Base, Patient, AuditLog, EncryptedData

logger = logging.getLogger(__name__)


class EncryptionManager:
    """Manages encryption and decryption for sensitive data"""
    
    def __init__(self, encryption_key: Optional[str] = None):
        if encryption_key:
            self.key = encryption_key.encode()
        else:
            self.key = self._generate_key()
        
        # Create Fernet cipher
        self.cipher = Fernet(base64.urlsafe_b64encode(self.key[:32]))
    
    def _generate_key(self) -> bytes:
        """Generate encryption key from environment or create new one"""
        password = SECURITY_CONFIG.get('encryption_key', 'default_password').encode()
        salt = b'mada_salt'  # In production, use random salt per record
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        return kdf.derive(password)
    
    def encrypt(self, data: str) -> bytes:
        """Encrypt sensitive data"""
        if isinstance(data, str):
            data = data.encode()
        return self.cipher.encrypt(data)
    
    def decrypt(self, encrypted_data: bytes) -> str:
        """Decrypt sensitive data"""
        decrypted = self.cipher.decrypt(encrypted_data)
        return decrypted.decode()


class DatabaseManager:
    """
    Manages database operations with HIPAA compliance features
    """
    
    def __init__(self):
        self.engine = None
        self.SessionLocal = None
        self.encryption_manager = EncryptionManager()
        self._setup_database()
        self._setup_audit_logging()
    
    def _setup_database(self):
        """Setup database connection and session factory"""
        try:\n            # Create database URL\n            db_url = (\n                f\"postgresql://{DATABASE_CONFIG['username']}:\"\n                f\"{DATABASE_CONFIG['password']}@{DATABASE_CONFIG['host']}:\"\n                f\"{DATABASE_CONFIG['port']}/{DATABASE_CONFIG['database']}\"\n            )\n            \n            # Create engine with connection pooling\n            self.engine = create_engine(\n                db_url,\n                poolclass=QueuePool,\n                pool_size=DATABASE_CONFIG.get('pool_size', 10),\n                max_overflow=DATABASE_CONFIG.get('max_overflow', 20),\n                pool_pre_ping=True,\n                echo=os.getenv('DB_ECHO', 'False').lower() == 'true'\n            )\n            \n            # Create session factory\n            self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)\n            \n            logger.info(\"Database connection established successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to setup database: {e}\")\n            raise\n    \n    def _setup_audit_logging(self):\n        \"\"\"Setup automatic audit logging for database operations\"\"\"\n        @event.listens_for(Engine, \"before_cursor_execute\")\n        def receive_before_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n            # Store the start time\n            context._query_start_time = datetime.utcnow()\n        \n        @event.listens_for(Engine, \"after_cursor_execute\")\n        def receive_after_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n            # Log slow queries\n            if hasattr(context, '_query_start_time'):\n                duration = datetime.utcnow() - context._query_start_time\n                if duration.total_seconds() > 1.0:  # Log queries slower than 1 second\n                    logger.warning(f\"Slow query detected: {duration.total_seconds():.2f}s - {statement[:100]}...\")\n    \n    def create_tables(self):\n        \"\"\"Create all database tables\"\"\"\n        try:\n            Base.metadata.create_all(bind=self.engine)\n            logger.info(\"Database tables created successfully\")\n        except Exception as e:\n            logger.error(f\"Failed to create tables: {e}\")\n            raise\n    \n    def drop_tables(self):\n        \"\"\"Drop all database tables (use with caution!)\"\"\"\n        try:\n            Base.metadata.drop_all(bind=self.engine)\n            logger.warning(\"All database tables dropped\")\n        except Exception as e:\n            logger.error(f\"Failed to drop tables: {e}\")\n            raise\n    \n    @contextmanager\n    def get_session(self):\n        \"\"\"Get database session with automatic cleanup\"\"\"\n        session = self.SessionLocal()\n        try:\n            yield session\n            session.commit()\n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Database session error: {e}\")\n            raise\n        finally:\n            session.close()\n    \n    def log_audit_event(self, session: Session, action: str, table_name: str = None, \n                       record_id: str = None, patient_id: str = None, \n                       user_id: str = None, details: Dict[str, Any] = None,\n                       ip_address: str = None, user_agent: str = None):\n        \"\"\"Log audit event for HIPAA compliance\"\"\"\n        try:\n            audit_log = AuditLog(\n                patient_id=patient_id,\n                user_id=user_id,\n                action=action,\n                table_name=table_name,\n                record_id=record_id,\n                details=details,\n                ip_address=ip_address,\n                user_agent=user_agent\n            )\n            session.add(audit_log)\n            session.flush()  # Don't commit here, let the caller handle it\n        except Exception as e:\n            logger.error(f\"Failed to log audit event: {e}\")\n    \n    def create_patient(self, patient_data: Dict[str, Any], user_id: str = None,\n                      ip_address: str = None) -> Optional[str]:\n        \"\"\"Create new patient with audit logging\"\"\"\n        with self.get_session() as session:\n            try:\n                # Create patient\n                patient = Patient(**patient_data)\n                session.add(patient)\n                session.flush()  # Get the ID\n                \n                # Log audit event\n                self.log_audit_event(\n                    session, 'create', 'patients', str(patient.id), \n                    str(patient.id), user_id, {'action': 'patient_created'},\n                    ip_address\n                )\n                \n                session.commit()\n                logger.info(f\"Patient created: {patient.id}\")\n                return str(patient.id)\n                \n            except Exception as e:\n                logger.error(f\"Failed to create patient: {e}\")\n                return None\n    \n    def get_patient(self, patient_id: str, user_id: str = None, \n                   ip_address: str = None) -> Optional[Patient]:\n        \"\"\"Get patient with audit logging\"\"\"\n        with self.get_session() as session:\n            try:\n                patient = session.query(Patient).filter(Patient.id == patient_id).first()\n                \n                if patient:\n                    # Log audit event\n                    self.log_audit_event(\n                        session, 'read', 'patients', patient_id, \n                        patient_id, user_id, {'action': 'patient_accessed'},\n                        ip_address\n                    )\n                \n                return patient\n                \n            except Exception as e:\n                logger.error(f\"Failed to get patient: {e}\")\n                return None\n    \n    def update_patient(self, patient_id: str, update_data: Dict[str, Any],\n                      user_id: str = None, ip_address: str = None) -> bool:\n        \"\"\"Update patient data with audit logging\"\"\"\n        with self.get_session() as session:\n            try:\n                patient = session.query(Patient).filter(Patient.id == patient_id).first()\n                if not patient:\n                    return False\n                \n                # Store old values for audit\n                old_values = {}\n                for key, value in update_data.items():\n                    if hasattr(patient, key):\n                        old_values[key] = getattr(patient, key)\n                        setattr(patient, key, value)\n                \n                # Log audit event\n                self.log_audit_event(\n                    session, 'update', 'patients', patient_id,\n                    patient_id, user_id, \n                    {'old_values': old_values, 'new_values': update_data},\n                    ip_address\n                )\n                \n                session.commit()\n                logger.info(f\"Patient updated: {patient_id}\")\n                return True\n                \n            except Exception as e:\n                logger.error(f\"Failed to update patient: {e}\")\n                return False\n    \n    def delete_patient(self, patient_id: str, user_id: str = None, \n                      ip_address: str = None, soft_delete: bool = True) -> bool:\n        \"\"\"Delete patient (soft delete by default for HIPAA compliance)\"\"\"\n        with self.get_session() as session:\n            try:\n                patient = session.query(Patient).filter(Patient.id == patient_id).first()\n                if not patient:\n                    return False\n                \n                if soft_delete:\n                    # Soft delete - mark as inactive\n                    patient.is_active = False\n                    action = 'soft_delete'\n                else:\n                    # Hard delete (use with extreme caution)\n                    session.delete(patient)\n                    action = 'delete'\n                \n                # Log audit event\n                self.log_audit_event(\n                    session, action, 'patients', patient_id,\n                    patient_id, user_id, {'action': f'patient_{action}'},\n                    ip_address\n                )\n                \n                session.commit()\n                logger.warning(f\"Patient {'soft-' if soft_delete else ''}deleted: {patient_id}\")\n                return True\n                \n            except Exception as e:\n                logger.error(f\"Failed to delete patient: {e}\")\n                return False\n    \n    def search_patients(self, search_criteria: Dict[str, Any], user_id: str = None,\n                       ip_address: str = None, limit: int = 100) -> List[Patient]:\n        \"\"\"Search patients with audit logging\"\"\"\n        with self.get_session() as session:\n            try:\n                query = session.query(Patient).filter(Patient.is_active == True)\n                \n                # Apply search criteria\n                if 'first_name' in search_criteria:\n                    query = query.filter(Patient.first_name.ilike(f\"%{search_criteria['first_name']}%\"))\n                if 'last_name' in search_criteria:\n                    query = query.filter(Patient.last_name.ilike(f\"%{search_criteria['last_name']}%\"))\n                if 'email' in search_criteria:\n                    query = query.filter(Patient.email.ilike(f\"%{search_criteria['email']}%\"))\n                if 'date_of_birth' in search_criteria:\n                    query = query.filter(Patient.date_of_birth == search_criteria['date_of_birth'])\n                \n                patients = query.limit(limit).all()\n                \n                # Log audit event\n                self.log_audit_event(\n                    session, 'search', 'patients', None, None, user_id,\n                    {'search_criteria': search_criteria, 'results_count': len(patients)},\n                    ip_address\n                )\n                \n                return patients\n                \n            except Exception as e:\n                logger.error(f\"Failed to search patients: {e}\")\n                return []\n    \n    def store_encrypted_data(self, patient_id: str, data_type: str, \n                           sensitive_data: str, user_id: str = None) -> bool:\n        \"\"\"Store encrypted sensitive data\"\"\"\n        with self.get_session() as session:\n            try:\n                # Encrypt the data\n                encrypted_content = self.encryption_manager.encrypt(sensitive_data)\n                \n                # Create encrypted data record\n                encrypted_record = EncryptedData(\n                    patient_id=patient_id,\n                    data_type=data_type,\n                    encrypted_content=encrypted_content\n                )\n                \n                session.add(encrypted_record)\n                \n                # Log audit event\n                self.log_audit_event(\n                    session, 'create', 'encrypted_data', None,\n                    patient_id, user_id, \n                    {'data_type': data_type, 'encrypted': True}\n                )\n                \n                session.commit()\n                return True\n                \n            except Exception as e:\n                logger.error(f\"Failed to store encrypted data: {e}\")\n                return False\n    \n    def retrieve_encrypted_data(self, patient_id: str, data_type: str,\n                               user_id: str = None, ip_address: str = None) -> Optional[str]:\n        \"\"\"Retrieve and decrypt sensitive data\"\"\"\n        with self.get_session() as session:\n            try:\n                encrypted_record = session.query(EncryptedData).filter(\n                    EncryptedData.patient_id == patient_id,\n                    EncryptedData.data_type == data_type\n                ).first()\n                \n                if not encrypted_record:\n                    return None\n                \n                # Decrypt the data\n                decrypted_data = self.encryption_manager.decrypt(encrypted_record.encrypted_content)\n                \n                # Log audit event\n                self.log_audit_event(\n                    session, 'read', 'encrypted_data', str(encrypted_record.id),\n                    patient_id, user_id, \n                    {'data_type': data_type, 'decrypted': True},\n                    ip_address\n                )\n                \n                return decrypted_data\n                \n            except Exception as e:\n                logger.error(f\"Failed to retrieve encrypted data: {e}\")\n                return None\n    \n    def get_audit_trail(self, patient_id: str = None, user_id: str = None,\n                       start_date: datetime = None, end_date: datetime = None,\n                       limit: int = 1000) -> List[AuditLog]:\n        \"\"\"Get audit trail for compliance reporting\"\"\"\n        with self.get_session() as session:\n            try:\n                query = session.query(AuditLog)\n                \n                if patient_id:\n                    query = query.filter(AuditLog.patient_id == patient_id)\n                if user_id:\n                    query = query.filter(AuditLog.user_id == user_id)\n                if start_date:\n                    query = query.filter(AuditLog.timestamp >= start_date)\n                if end_date:\n                    query = query.filter(AuditLog.timestamp <= end_date)\n                \n                return query.order_by(AuditLog.timestamp.desc()).limit(limit).all()\n                \n            except Exception as e:\n                logger.error(f\"Failed to get audit trail: {e}\")\n                return []\n    \n    def backup_database(self, backup_path: str) -> bool:\n        \"\"\"Create database backup\"\"\"\n        try:\n            # This would typically use pg_dump for PostgreSQL\n            # Implementation depends on the specific database system\n            logger.info(f\"Database backup created at: {backup_path}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to create database backup: {e}\")\n            return False\n    \n    def health_check(self) -> Dict[str, Any]:\n        \"\"\"Check database health and connection status\"\"\"\n        try:\n            with self.get_session() as session:\n                # Simple query to test connection\n                session.execute(\"SELECT 1\")\n                \n                # Get connection pool status\n                pool = self.engine.pool\n                pool_status = {\n                    'pool_size': pool.size(),\n                    'checked_in': pool.checkedin(),\n                    'overflow': pool.overflow(),\n                    'invalidated': pool.invalidated()\n                }\n                \n                return {\n                    'status': 'healthy',\n                    'timestamp': datetime.utcnow().isoformat(),\n                    'pool_status': pool_status\n                }\n        \n        except Exception as e:\n            logger.error(f\"Database health check failed: {e}\")\n            return {\n                'status': 'unhealthy',\n                'timestamp': datetime.utcnow().isoformat(),\n                'error': str(e)\n            }
